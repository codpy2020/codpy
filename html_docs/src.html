

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API &mdash; CodPy 0.0.10 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=7ab3649f" />
      <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=a83ce22a"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Documentation" href="documentation.html" />
    <link rel="prev" title="Linear Algebra module" href="lalg.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            CodPy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Library Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="description.html">CodPy description</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel.html">Kernel class</a></li>
<li class="toctree-l1"><a class="reference internal" href="core.html">Kernels and maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="permutation.html">Permutation algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">Sampling algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="algs.html">General algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="pde.html">PDE module</a></li>
<li class="toctree-l1"><a class="reference internal" href="lalg.html">Linear Algebra module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Learn and Explore:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#src-algs-module">src.algs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#src-core-module">src.core module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#src-pde-module">src.pde module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#src-permutation-module">src.permutation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#src-sampling-module">src.sampling module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-contents">Module contents</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CodPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/src.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api">
<h1>API<a class="headerlink" href="#api" title="Link to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="src-algs-module">
<h2>src.algs module<a class="headerlink" href="#src-algs-module" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codpy.algs.</span></span><span class="sig-name descname"><span class="pre">alg</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Pi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">HybridGreedyNystroem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'classifier'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Knm_inv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="src-core-module">
<h2>src.core module<a class="headerlink" href="#src-core-module" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">set_verbose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">set_num_threads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">op</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Performs projection in kernel regression for efficient computation, targeting a lower sampling space.
.. note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>The performance of the function depends on two ingredients:

* ``kernel`` function
* ``map``
</pre></div>
</div>
<p class="rubric">Example</p>
<p>With NumPy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xtrain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xtest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx_train</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx_test</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx_test_pred</span> <span class="o">=</span> <span class="n">projection</span><span class="p">(</span><span class="n">xtrain</span><span class="p">,</span> <span class="n">xtrain</span><span class="p">,</span> <span class="n">xtest</span><span class="p">,</span> <span class="n">fx_train</span><span class="p">,</span>
<span class="go">kernel_fun = &quot;tensornorm&quot;, map = &quot;unitcube&quot;,</span>
<span class="go">       polynomial_order=2)</span>
</pre></div>
</div>
<p>With pandas DataFrames</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_train_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_train_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z_test_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx_train_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">projected_responses</span> <span class="o">=</span> <span class="n">projection</span><span class="p">(</span><span class="n">x_train_df</span><span class="p">,</span> <span class="n">y_train_df</span><span class="p">,</span> <span class="n">z_test_df</span><span class="p">,</span> <span class="n">fx_train_df</span><span class="p">,</span> <span class="n">kernel_fun</span> <span class="o">=</span> <span class="s2">&quot;tensornorm&quot;</span><span class="p">,</span> <span class="nb">map</span> <span class="o">=</span> <span class="s2">&quot;unitcube&quot;</span><span class="p">,</span>
<span class="go">       polynomial_order=2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">extrapolation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Performs extrapolation in the context of kernel regression.</p>
<p>This method leverages the kernel regression framework to extrapolate values between data points.
.. note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>The performance of the function depends on two ingredients:

* ``kernel`` function
* ``map``
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">interpolation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Performs interpolation in the context of kernel regression.</p>
<p>This method leverages the kernel regression framework to interpolate values between data points.
.. note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>The performance of the function depends on two ingredients:

* ``kernel`` function
* ``map``
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">gradient_denoiser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>A function for performing least squares regression penalized by the norm of the gradient,
induced by a positive definite (PD) kernel.</p>
<p>This functioon initializes with various parameters and sets up a regression framework
that includes regularization based on the gradient’s magnitude. It is designed to
work with gradient norms induced by a PD kernel.
:returns: The denoised output for the input data.</p>
<p>Example:</p>
<p>Initialize the denoiser with input data ‘x’ and optional parameters</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xtrain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xtest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx_train</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx_test</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="mi">2</span>
</pre></div>
</div>
<p># Perform denoising on the input data or new data points ‘z’
op.denoiser(xtrain, xtest, fx_train, kernel_fun = “maternnorm”, map = “standardmean”)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate the kernel-induced norm based on the provided matrices.</p>
<p>This function computes a norm projection using the kernel initialization parameters.
It supports flexible argument input through keyword arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>list</em><em>, </em><em>optional</em>) – The first matrix. Defaults to an empty list.</p></li>
<li><p><strong>y</strong> (<em>list</em><em>, </em><em>optional</em>) – The second matrix. Defaults to a list containing <cite>x</cite>.</p></li>
<li><p><strong>z</strong> (<em>list</em><em>, </em><em>optional</em>) – The third matrix. Defaults to an empty list.</p></li>
<li><p><strong>fx</strong> (<em>list</em><em>, </em><em>optional</em>) – The fourth matrix. Defaults to an empty list.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The performance of the function depends on two ingredients:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">kernel</span></code> function</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">map</span></code></p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span></dt>
<dd><p>Computes the regressors or coefficients for kernelized regression, using a specified PD kernel.</p>
<p>This method initializes the kernel function with the given parameters and then
computes the regression coefficients based on the input datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.array</em>) – The input data points for which the regression coefficients are computed.</p></li>
<li><p><strong>y</strong> (<em>np.array</em>) – Internal parameter, can be y = x.</p></li>
<li><p><strong>fx</strong> (<em>np.array</em><em>, </em><em>optional</em>) – Responses associated with ‘x’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The computed regression coefficients or regressors that model the
relationship between the input data ‘x’ and the target ‘y’.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
<p>Available Kernels:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'gaussian'</span></code>: Gaussian kernel for smooth, continuous functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'tensornorm'</span></code>: Tensor norm kernel suitable for multidimensional data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'absnorm'</span></code>: Absolute norm kernel for robust performance in varied datasets.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matern'</span></code>: Matérn kernel useful in spatial statistics.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'multiquadricnorm'</span></code>: Multi-quadric norm kernel for flexible shape adaptation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'multiquadrictensor'</span></code>: Multi-quadric tensor kernel, a tensor-based variant offering flexible shape adaptation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'sincardtensor'</span></code>: Sinc cardinal tensor kernel, suitable for periodic and oscillatory data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'sincardsquaretensor'</span></code>: Sinc cardinal square tensor kernel, enhancing the sinc cardinal tensor kernel for certain data types.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'dotproduct'</span></code>: Dot product kernel, useful for linear classifications and regressions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'gaussianper'</span></code>: Gaussian periodic kernel, ideal for modeling periodic functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'maternnorm'</span></code>: Matérn norm kernel, a variation of the Matérn kernel for normalized spaces.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'scalarproduct'</span></code>: Scalar product kernel, a simple yet effective kernel for dot products.</p></li>
</ul>
</div></blockquote>
<p>Available Maps:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'linear'</span></code>: Linear map for straightforward transformations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'affine'</span></code>: Affine map for linear transformations with translation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'log'</span></code>: Logarithmic map for non-linear scaling.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'exp'</span></code>: Exponential map for rapidly increasing scales.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'scalestd'</span></code>: Standard scaling map that normalizes data by removing the mean and scaling to unit variance.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'erf'</span></code>: Error function map, useful for data normalization with a non-linear scale.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'erfinv'</span></code>: Inverse error function map, providing the inverse transformation of the error function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'scalefactor'</span></code>: Scaling factor map that applies a uniform scaling defined by a bandwidth or scale factor.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'bandwidth'</span></code>: Helper for setting the scale factor map with a specified bandwidth, typically used in kernel methods.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'grid'</span></code>: Grid map that projects data onto a grid, useful for discretizing continuous variables or spatial data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'unitcube'</span></code>: Unit cube map that scales data to fit within a unit cube, ensuring all features are within the range [0,1].</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'meandistance'</span></code>: Mean distance map that scales data based on the mean distance between data points.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'mindistance'</span></code>: Minimum distance map that scales data based on the minimum distance between data points.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'standardmin'</span></code>: Standard minimum map pipeline combining minimum distance scaling with other transformations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'standardmean'</span></code>: Standard mean map pipeline combining mean distance scaling with other transformations.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Knm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span></dt>
<dd><p>Computes the kernel matrix induced by a positive definite (pd) kernel.</p>
<p>This method calculates the kernel matrix k(x_i,y_j) using the input kernel function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – Input data points for the gradient computation. np.array of size N , D.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – Secondary data points used in the kernel computation. np.array of size M , D.</p></li>
<li><p><strong>fx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – optional-Function values or responses at the data points in <cite>x</cite>. np.array of size M , Df.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>matrix np.array of size (NxM) The computed kernel matrix, representing the kernel-induced distances or similarities between the data points in ‘x’ and ‘y’.
- prod(Knm(x,y),fx) else. This allow performance and memory optimizations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>if fx is empty</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Knm_inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – Input data points for the gradient computation. np.array of size N , D.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – Secondary data points used in the kernel computation. np.array of size M , D.</p></li>
<li><p><strong>fx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – optional-Function values or responses at the data points in <cite>x</cite>. np.array of size M , Df.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><dl class="simple">
<dt>if fx is empty: matrix np.array of size (NxM), that is the least square inverse of Knm(x,y).</dt><dd><ul>
<li><p>prod(Knm_inv(x,y),fx) else. This allow performance and memory optimizations. The output corresponds then to the coefficient of fx in the kernel induced basis.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>else:</dt><dd><ul>
<li><p>if fx is empty: matrix np.array of size (NxM), that corresponds to the least square computation (Knm(y,x)Knm(x,y)+reg)^{-1}Knm(y,x).</p></li>
<li><p>prod(Knm_inv(x,y),fx) else. This allow performance and memory optimizations. The output corresponds then to the coefficient of fx in the kernel induced basis.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>if reg is empty</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Dnm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span></dt>
<dd><p>Computes a distance matrix induced by a positive definite (pd) kernel.</p>
<p>This function calculates the distance matrix between sets of data points
x and y based on a specified pd kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.array</em>) – The first set of data points.</p></li>
<li><p><strong>y</strong> (<em>np.array</em>) – The second set of data points. If not provided, defaults to x.</p></li>
<li><p><strong>distance</strong> (<em>function</em><em>, </em><em>optional</em>) – a name of distance function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A distance matrix representing the distances between each pair of points in x and y as induced by the pd kernel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">discrepancy_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disc_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raw'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">norm_projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">distance_labelling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'min'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span></dt>
<dd><p>Computes and labels distances using a kernel-induced distance matrix.</p>
<p>This function calculates the distance matrix between two sets of data points (x and y) using
a specified kernel function. It then labels these distances based on either the softmax or softmin
indices, depending on the ‘max’ parameter in kwargs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.array</em>) – The first set of data points.</p></li>
<li><p><strong>y</strong> (<em>np.array</em>) – The second set of data points.</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em>) – The axis along which to compute the distances. Default is 1.</p></li>
<li><p><strong>max</strong> (<em>bool</em><em>, </em><em>optional</em>) – Determines the type of labelling:
- If True, uses softmax labelling.
- If False (default), uses softmin labelling.
:param kernel_fun: The name of the kernel function to use. Options include <code class="docutils literal notranslate"><span class="pre">'gaussian'</span></code>, <code class="docutils literal notranslate"><span class="pre">'tensornorm'</span></code>, etc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array of labelled distances between the data points in x and y.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">discrepancy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disc_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raw'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">discrepancy_functional</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_fun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tensornorm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unitcube'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polynomial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>A kernel-induced discrepancy between two distributions.</p>
<p>Discrepancy is a non-parametric method to test the equality of two distributions. It’s computed in a
Reproducing Kernel Hilbert Space (RKHS) using a specified kernel function.</p>
<p>Attributes:
Nx (int): The number of samples in the first distribution ‘x’.
x (array-like): The first distribution for which MMD is to be computed.
Kxx (float): The kernel-induced distance computed within ‘x’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like</em>) – The first input distribution.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>optional</em>) – The second input distribution. If not provided, it defaults to an empty list.</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments for the kernel function.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Computes the MMD between the distribution ‘ys’ and the initial distribution ‘x’.</p>
</dd></dl>

<p class="rubric">Example</p>
<p>Define two distributions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>Initialize discrepancy functional for ‘x’</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">discrepancy</span> <span class="o">=</span> <span class="n">discrepancy_functional</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute MMD between ‘x’ and ‘y’</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">discrepancy_value</span> <span class="o">=</span> <span class="n">discrepancy</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kinv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_fun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tensornorm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unitcube'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polynomial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kernel_fun</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the kernel function to use. Options include <code class="docutils literal notranslate"><span class="pre">'gaussian'</span></code>, <code class="docutils literal notranslate"><span class="pre">'tensornorm'</span></code>, etc.</p></li>
<li><p><strong>map</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, optional) – The name of the mapping function to apply. Options include <code class="docutils literal notranslate"><span class="pre">'linear'</span></code>, <code class="docutils literal notranslate"><span class="pre">'affine'</span></code>, etc.</p></li>
<li><p><strong>polynomial_order</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, optional) – The polynomial order for the kernel function. Defaults to <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p></li>
<li><p><strong>regularization</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, optional) – Regularization parameter for the kernel. Defaults to <code class="docutils literal notranslate"><span class="pre">1e-8</span></code>.</p></li>
<li><p><strong>rescale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, optional) – Whether to rescale the data.</p></li>
<li><p><strong>rescale_params</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, optional) – Parameters for data rescaling. Defaults to <code class="docutils literal notranslate"><span class="pre">{'max':</span> <span class="pre">1000,</span> <span class="pre">'seed':</span> <span class="pre">42}</span></code>.</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – Arbitrary keyword arguments.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">diffops</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">nabla_Knm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Args:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">nabla</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the kernel-induced gradient of a function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Input data points for the gradient computation.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Secondary data points used in the kernel computation.</p></li>
<li><p><strong>z</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Tertiary data points used in the kernel computation.</p></li>
<li><p><strong>fx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Function values or responses at the data points in <cite>x</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The computed gradient of the function.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fz</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient</span> <span class="o">=</span> <span class="n">diffops</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">fx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">nabla_inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the inverse of the kernel-induced gradient operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Input data points.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Secondary data points.</p></li>
<li><p><strong>z</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Tertiary data points.</p></li>
<li><p><strong>fz</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, optional) – The vector field for the inverse gradient computation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The computed inverse gradient of the vector field.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inv_gradient</span> <span class="o">=</span> <span class="n">nabla_inv</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">z_data</span><span class="p">,</span> <span class="n">fz</span><span class="o">=</span><span class="n">vector_field</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">nablaT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fz</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the divergence of a vector field using a kernel-induced method.</p>
<p>This function calculates the divergence (nabla transpose) of a vector field in the context of kernel methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class</strong> (<em>fz</em>) – <cite>numpy.ndarray</cite>: The input data points where the divergence is calculated.</p></li>
<li><p><strong>class</strong> – <cite>numpy.ndarray</cite>: Secondary data points used in the kernel computation.</p></li>
<li><p><strong>class</strong> – <cite>numpy.ndarray</cite>: Tertiary data points used in the kernel computation.</p></li>
<li><p><strong>class</strong> – <cite>numpy.ndarray</cite>: The vector field for which the divergence is computed. Defaults to an empty list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>numpy.ndarray</cite>: The computed divergence of the vector field at each point in <cite>x</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>class</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Example usage with NumPy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divergence</span> <span class="o">=</span> <span class="n">nablaT</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">z_data</span><span class="p">,</span> <span class="n">fz</span><span class="o">=</span><span class="n">vector_field</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">nablaT_inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the inverse of the transposed gradient operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Input data points.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Secondary data points.</p></li>
<li><p><strong>z</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Tertiary data points.</p></li>
<li><p><strong>fx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Function values or responses at the data points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The computed inverse of the transposed gradient.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inv_transpose_gradient</span> <span class="o">=</span> <span class="n">nablaT_inv</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">z_data</span><span class="p">,</span> <span class="n">fx_data</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">nablaT_nabla</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><blockquote>
<div><p>Compute the kernel-induced discrete Laplace operator.</p>
<p>This function calculates the discrete Laplace operator using a kernel method. It computes this
operator as the dot product of the transposed gradient vector and the gradient vector, which is
consistent with a differential operator that resembles the Laplace operator in its behavior.</p>
<dl>
<dt>Args:</dt><dd><p>x (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>): Input data points for the Laplace operator computation.
y (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>): Secondary data points used in the kernel computation.
fx (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>): Function values or responses at the data points.</p>
<p>class:<cite>numpy.ndarray</cite>: The computed discrete Laplace operator values for each point in <cite>x</cite>.</p>
</dd>
<dt>Note:</dt><dd><p>The discrete Laplace operator computed here is not consistent with the “true” Laplace operator,
but instead aligns with another differential operator, described as (-</p>
</dd>
</dl>
</div></blockquote>
<p>abla cdot (
abla fmu)).</p>
<blockquote>
<div><dl>
<dt>Example:</dt><dd><p>Example usage with NumPy arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">laplace_operator</span> <span class="o">=</span> <span class="n">nablaT_nabla</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">fx_data</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">nablaT_nabla_inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Args:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Leray_T</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Leray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the Leray operator for a given set of input matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Input data points.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Secondary data points.</p></li>
<li><p><strong>fx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Function values or responses at the data points.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em>) – Arbitrary keyword arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The result of the Leray operator computation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">leray_result</span> <span class="o">=</span> <span class="n">Leray</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">fx_data</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span></dt>
<dd><p>Compute the kernel-induced Hessian matrix of a function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Input data points where the Hessian matrix is calculated.</p></li>
<li><p><strong>z</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Tertiary data points used in the kernel computation.</p></li>
<li><p><strong>fx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code>) – Function values or responses at the data points in <cite>x</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The computed Hessian matrix of the function.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function computes the Hessian matrix for each input data point. If the ‘fx’ parameter is provided,
the function computes a modified Hessian matrix using this additional information.</p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hessian_matrix</span> <span class="o">=</span> <span class="n">hessian</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">z_data</span><span class="p">,</span> <span class="n">fx_data</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">kernel_interface</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">rescale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">42</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">get_kernel_ptr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_kernel_ptr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_polynomial_order</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_regularization</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">pipe_kernel_ptr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">pipe_kernel_fun</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">map_setters</span></span></dt>
<dd><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strings</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_linear_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a linear map for the kernel.</p>
<p>Args:
- <a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs: Arbitrary keyword arguments for the linear map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_affine_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set an affine map for the kernel.</p>
<p>Args:
- <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs: Arbitrary keyword arguments for the affine map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_log_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a logarithmic map for the kernel.</p>
<p>Args:
- <a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs: Arbitrary keyword arguments for the log map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_exp_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set an exponential map for the kernel.</p>
<p>Args:
- <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs: Arbitrary keyword arguments for the exponential map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_scale_std_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a standard scaling map for the kernel.</p>
<p>Args:
- <a href="#id9"><span class="problematic" id="id10">**</span></a>kwargs: Arbitrary keyword arguments for the scale standard map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_erf_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set an error function (ERF) map for the kernel.</p>
<p>Args:
- <a href="#id11"><span class="problematic" id="id12">**</span></a>kwargs: Arbitrary keyword arguments for the ERF map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_erfinv_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set an inverse error function (ERF) map for the kernel.</p>
<p>Args:
- <a href="#id13"><span class="problematic" id="id14">**</span></a>kwargs: Arbitrary keyword arguments for the inverse ERF map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_scale_factor_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a scaling factor map for the kernel.</p>
<p>Args:
- <a href="#id15"><span class="problematic" id="id16">**</span></a>kwargs: Arbitrary keyword arguments for the scale factor map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_scale_factor_helper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Helper function to set a scaling factor map with specified bandwidth.</p>
<p>Args:
- <a href="#id17"><span class="problematic" id="id18">**</span></a>kwargs: Arbitrary keyword arguments, including ‘bandwidth’ for the scale factor map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_unitcube_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a unit cube map for the kernel.</p>
<p>Args:
- <a href="#id19"><span class="problematic" id="id20">**</span></a>kwargs: Arbitrary keyword arguments for the unit cube map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_grid_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a grid map for the kernel.</p>
<p>Args:
- <a href="#id21"><span class="problematic" id="id22">**</span></a>kwargs: Arbitrary keyword arguments for the grid map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_mean_distance_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a mean distance map for the kernel.</p>
<p>Args:
- <a href="#id23"><span class="problematic" id="id24">**</span></a>kwargs: Arbitrary keyword arguments for the mean distance map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_min_distance_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a minimum distance map for the kernel.</p>
<p>Args:
- <a href="#id25"><span class="problematic" id="id26">**</span></a>kwargs: Arbitrary keyword arguments for the minimum distance map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_standard_mean_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a standard mean map pipeline for the kernel.</p>
<p>This function sets a mean distance map and then pipes it through the erf-inverse and unit cube maps.</p>
<p>Args:
- <a href="#id27"><span class="problematic" id="id28">**</span></a>kwargs: Arbitrary keyword arguments for the standard mean map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_standard_min_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a standard minimum map pipeline for the kernel.</p>
<p>This function sets a minimum distance map and then pipes it through the erf-inverse and unit cube maps.</p>
<p>Args:
- <a href="#id29"><span class="problematic" id="id30">**</span></a>kwargs: Arbitrary keyword arguments for the standard minimum map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_unitcube_min_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a unit cube minimum map pipeline for the kernel.</p>
<p>This function sets a minimum distance map and then pipes it through the unit cube map.</p>
<p>Args:
- <a href="#id31"><span class="problematic" id="id32">**</span></a>kwargs: Arbitrary keyword arguments for the unit cube minimum map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_unitcube_erfinv_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a unit cube erf-inverse map pipeline for the kernel.</p>
<p>This function sets an erf-inverse map and then pipes it through the unit cube map.</p>
<p>Args:
- <a href="#id33"><span class="problematic" id="id34">**</span></a>kwargs: Arbitrary keyword arguments for the unit cube erf-inverse map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_unitcube_mean_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a unit cube mean map pipeline for the kernel.</p>
<p>This function sets a mean distance map and then pipes it through the unit cube map.</p>
<p>Args:
- <a href="#id35"><span class="problematic" id="id36">**</span></a>kwargs: Arbitrary keyword arguments for the unit cube mean map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">map_helper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Helper function to create a custom map setting function.</p>
<p>This function creates a partial function for a specified map setter with provided arguments.</p>
<p>Args:
- map_setter (function): The map setter function to be used.
- <a href="#id37"><span class="problematic" id="id38">**</span></a>kwargs: Arbitrary keyword arguments for the map setter function.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">check_map_strings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strings</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">set_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">checkkernel_strings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strings</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">set_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">kernel_setters</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">kernel_helper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polynomial_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polynomial_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the kernel function with specified parameters.</p>
<p>This method configures the kernel function used in the calculations. It allows setting
the type of kernel, its polynomial order, regularization factor, and an optional mapping function.</p>
<p>Args:
- kernel_string (str): The name of the kernel function to use.
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function to apply.</p>
<p>The method configures the kernel and its associated parameters, preparing it for use
in subsequent calculations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_linear_regressor_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the linear regression kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function to apply.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_absnormkernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the absolute norm kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function to apply.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_tensornorm_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the tensor norm kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function to apply.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_gaussian_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the Gaussian kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function to apply.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_matern_tensor_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the Matérn tensor kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function to apply.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">default_multiquadricnormkernel_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a standard mean map pipeline for the kernel.</p>
<p>This function sets a mean distance map and then pipes it through the erf-inverse and unit cube maps.</p>
<p>Args:
- <a href="#id39"><span class="problematic" id="id40">**</span></a>kwargs: Arbitrary keyword arguments for the standard mean map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_multiquadricnorm_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map=functools.partial(&lt;function</span> <span class="pre">map_setters.set_standard_mean_map&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance='norm2')</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the multi-quadric norm kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function defined as <cite>default_multiquadricnormkernel_map</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">default_multiquadrictensorkernel_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a standard minimum map pipeline for the kernel.</p>
<p>This function sets a minimum distance map and then pipes it through the erf-inverse and unit cube maps.</p>
<p>Args:
- <a href="#id41"><span class="problematic" id="id42">**</span></a>kwargs: Arbitrary keyword arguments for the standard minimum map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_multiquadrictensor_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map=functools.partial(&lt;function</span> <span class="pre">map_setters.set_standard_min_map&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance='normifty')</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the multi-quadric tensor kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function defined as <cite>default_multiquadrictensorkernel_map</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">default_sincardtensorkernel_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a minimum distance map for the kernel.</p>
<p>Args:
- <a href="#id43"><span class="problematic" id="id44">**</span></a>kwargs: Arbitrary keyword arguments for the minimum distance map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_sincardtensor_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map=functools.partial(&lt;function</span> <span class="pre">map_setters.set_min_distance_map&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance='normifty')</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the sinc cardinal tensor kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function defined as <cite>default_sincardtensorkernel_map</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">default_sincardsquaretensorkernel_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Set a minimum distance map for the kernel.</p>
<p>Args:
- <a href="#id45"><span class="problematic" id="id46">**</span></a>kwargs: Arbitrary keyword arguments for the minimum distance map configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_sincardsquaretensor_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map=functools.partial(&lt;function</span> <span class="pre">map_setters.set_min_distance_map&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance='normifty')</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the sinc cardinal square tensor kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function defined as <cite>default_sincardsquaretensorkernel_map</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_dotproduct_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the dot product kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function to apply.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_gaussianper_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the Gaussian periodic kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function to apply.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_matern_norm_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map=&lt;function</span> <span class="pre">map_setters.set_mean_distance_map&gt;</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the Matérn norm kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function defined as <cite>map_setters.set_mean_distance_map</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set_scalar_product_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the scalar product kernel with specified parameters.</p>
<p>Args:
- polynomial_order (int): The polynomial order for the kernel function.
- regularization (float): The regularization parameter for the kernel.
- set_map (callable, optional): An optional mapping function to apply.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.core.</span></span><span class="sig-name descname"><span class="pre">kernel_setter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polynomial_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandwidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set the kernel function with specified parameters using string identifiers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kernel</strong> (<em>str</em>) – The name of the kernel function to use.</p></li>
<li><p><strong>map</strong> (<em>str</em>) – The name of the mapping function to use.</p></li>
<li><p><strong>polynomial_order</strong> (<em>int</em>) – The polynomial order for the kernel function.</p></li>
<li><p><strong>regularization</strong> (<em>float</em>) – The regularization parameter for the kernel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The configured kernel function.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="src-pde-module">
<h2>src.pde module<a class="headerlink" href="#src-pde-module" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.pde.</span></span><span class="sig-name descname"><span class="pre">CrankNicolson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Implement the Crank-Nicolson discretization scheme for numerical solution of partial differential equations.</p>
<p>The Crank-Nicolson method is a time-stepping scheme that averages the explicit (forward Euler) and implicit
(backward Euler) methods. This method is known for its stability and accuracy, especially for stiff equations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>array_like</em>) – The coefficient matrix used in the differential equation.</p></li>
<li><p><strong>dt</strong> (<em>float</em><em>, </em><em>optional</em>) – The time step size. Defaults to 0.</p></li>
<li><p><strong>u0</strong> (<em>array_like</em><em>, </em><em>optional</em>) – The initial condition (state at time t=0). Defaults to an empty list.</p></li>
<li><p><strong>**kwargs</strong> – <p>Arbitrary keyword arguments, which may include:
theta (float, optional): A parameter that balances between explicit and implicit methods.</p>
<blockquote>
<div><p>Default is 0.5, which gives the Crank-Nicolson scheme.
Values range from 0 (fully explicit) to 1 (fully implicit).</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The numerical solution of the differential equation at the next time step.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Coefficient matrix A for the differential equation</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>Initial condition</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>Time step size</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>
</pre></div>
</div>
<p>Compute the next time step solution</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u_next</span> <span class="o">=</span> <span class="n">CrankNicolson</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">u0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.pde.</span></span><span class="sig-name descname"><span class="pre">taylor_expansion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nabla=&lt;function</span> <span class="pre">diffops.nabla&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hessian=&lt;function</span> <span class="pre">diffops.hessian&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Perform a Taylor series expansion to approximate the function values at new points.</p>
<p>This function approximates the values of a given function at new points ‘z’ based on its values
and derivatives at points ‘x’. It supports first and second order (gradient and Hessian) expansions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array_like</em>) – Points where the function values and derivatives are known.</p></li>
<li><p><strong>y</strong> (<em>array_like</em>) – Additional parameter, typically used in the computation of derivatives.</p></li>
<li><p><strong>z</strong> (<em>array_like</em>) – Points where the function values are to be approximated.</p></li>
<li><p><strong>fx</strong> (<em>array_like</em>) – Known function values at points ‘x’.</p></li>
<li><p><strong>nabla</strong> (<em>function</em><em>, </em><em>optional</em>) – Function to compute the gradient. Default is diffops.nabla.</p></li>
<li><p><strong>hessian</strong> (<em>function</em><em>, </em><em>optional</em>) – Function to compute the Hessian matrix. Default is diffops.hessian.</p></li>
<li><p><strong>**kwargs</strong> – <p>Arbitrary keyword arguments, which may include:
indices (list, optional): Precomputed indices for mapping ‘x’ to ‘z’.</p>
<blockquote>
<div><p>If not provided, they will be computed.</p>
</div></blockquote>
<p>taylor_order (int, optional): The order of the Taylor expansion (1 or 2). Default is 1.
taylor_explanation (dict, optional): A dictionary to store intermediate results for analysis.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Approximated function values at points ‘z’ using Taylor expansion.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Define points ‘x’, ‘y’, ‘z’, and function values ‘fx’</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>Perform Taylor expansion</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fz_approx</span> <span class="o">=</span> <span class="n">taylor_expansion</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="src-permutation-module">
<h2>src.permutation module<a class="headerlink" href="#src-permutation-module" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.permutation.</span></span><span class="sig-name descname"><span class="pre">map_invertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_in</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Invert a mapping, transforming a map from one distribution to another into its inverse.
It is an optimized invertion algorithm, designed to handle large scale map invertion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>map</strong> (<em>dict</em><em> or </em><em>similar</em>) – The mapping to invert.</p></li>
<li><p><strong>type_in</strong> (<em>type</em><em>, </em><em>optional</em>) – The type of the input map. If None, the type of ‘map’ is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The inverted map, with the type specified by ‘type_in’.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">original_map</span> <span class="o">=</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inverted_map</span> <span class="o">=</span> <span class="n">map_inversion</span><span class="p">(</span><span class="n">original_map</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.permutation.</span></span><span class="sig-name descname"><span class="pre">scipy_lsap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span></dt>
<dd><p>Solve the Linear Sum Assignment Problem (LSAP) using the SciPy optimization module.</p>
<p>This function finds an optimal assignment that minimizes the total cost based on the
cost matrix C. It uses the <cite>linear_sum_assignment</cite> method from SciPy, which implements
the Hungarian algorithm (or Munkres algorithm) for this purpose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>C</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – A 2D array representing the cost matrix. Each element <code class="docutils literal notranslate"><span class="pre">C[i,</span> <span class="pre">j]</span></code> is the cost
of assigning the ith worker to the jth job.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array representing the optimal assignment. For each job (column in the cost matrix), it gives the index of the worker assigned to that job.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Create a cost matrix</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cost_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</pre></div>
</div>
<p>Solve the LSAP</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">optimal_assignment</span> <span class="o">=</span> <span class="n">scipy_lsap</span><span class="p">(</span><span class="n">cost_matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">optimal_assignment</span><span class="p">)</span>
<span class="go"># Output: [1, 0, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.permutation.</span></span><span class="sig-name descname"><span class="pre">lsap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span></dt>
<dd><p>Solve the Linear Sum Assignment Problem (LSAP) using CodPy’s optimization module.
The codpy LSAP might provide a slightly faster alternative than scipy LSAP module, as it is a C++ optimized version of it.
It comes also with a parallelized, but sub optimal version, for large scale lsap problems.</p>
<p>This function finds an optimal assignment that minimizes the total cost based on the
cost matrix C.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – A 2D array representing the cost matrix. Each element <code class="docutils literal notranslate"><span class="pre">C[i,</span> <span class="pre">j]</span></code> is the cost
of assigning the ith worker to the jth job.</p></li>
<li><p><strong>True</strong> (<em>sub=False /</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array representing the optimal assignment. For each job (column in the cost matrix), it gives the index of the worker assigned to that job.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Create a cost matrix</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cost_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</pre></div>
</div>
<p>Solve the LSAP</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">optimal_assignment</span> <span class="o">=</span> <span class="n">scipy_lsap</span><span class="p">(</span><span class="n">cost_matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">optimal_assignment</span><span class="p">)</span>
<span class="go"># Output: [1, 0, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.permutation.</span></span><span class="sig-name descname"><span class="pre">grid_projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.permutation.</span></span><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ny</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sharp_discrepancy_xmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sharp_discrepancy_seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Match function to resample or reorder data points in x to match a specified distribution size Ny.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>numpy.ndarray</em><em> or </em><em>pandas.DataFrame</em>) – Input data points to be matched.</p></li>
<li><p><strong>Ny</strong> (<em>int</em>) – Number of points to match to, if None, matches to the size of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><strong>sharp_discrepancy_xmax</strong> (<em>int</em>) – Optional parameter for sharp discrepancy, max value.</p></li>
<li><p><strong>sharp_discrepancy_seed</strong> (<em>int</em>) – Optional seed value for random selection in sharp discrepancy.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Matched data points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray or pandas.DataFrame</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="src-sampling-module">
<h2>src.sampling module<a class="headerlink" href="#src-sampling-module" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">kernel_density_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_fun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandwidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{'max':</span> <span class="pre">2000,</span> <span class="pre">'seed':</span> <span class="pre">42}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><blockquote>
<div><p>Estimate the kernel density of a distribution.</p>
<p>This function implements a kernel density estimator (KDE), a non-parametric method to estimate
the probability density function of a random variable. It evaluates the density estimate based on
two input distributions using a specified kernel function.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – <dl>
<dt>Arbitrary keyword arguments, including:</dt><dd><p>x (array-like): The first input distribution for which the density estimate is to be computed.
y (array-like): The second input distribution used in the density estimation process.
kernel (optional): The kernel function to be used for density estimation. This can be specified</p>
<blockquote>
<div><p>as part of the kwargs. If not specified, a default kernel is used.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>array-like: The estimated density values based on the kernel density estimation.</p>
</dd>
<dt>Example:</dt><dd><p>Two sample distributions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>Compute the kernel density estimation</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">density</span> <span class="o">=</span> <span class="n">kernel_density_estimator</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">kernel_conditional_density_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bandwidth'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandwidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{'max':</span> <span class="pre">2000,</span> <span class="pre">'seed':</span> <span class="pre">42}</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Estimate the conditional density of ‘y’ given ‘x’ using the Nadaraya-Watson estimator.</p>
<p>This function calculates the conditional density of values in ‘y_vals’ given the values in ‘x_vals’,
based on a joint distribution (‘x_data’, ‘y_data’). It uses KDE method for the estimation, with the
kernel specified in ‘kwargs’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_vals</strong> (<em>array-like</em>) – Values of ‘x’ for which the conditional density of ‘y’ is estimated.</p></li>
<li><p><strong>y_vals</strong> (<em>array-like</em>) – Values of ‘y’ for which the density is to be estimated conditionally on ‘x_vals’.</p></li>
<li><p><strong>x_data</strong> (<em>array-like</em>) – Observed data for ‘x’ in the joint distribution with ‘y’.</p></li>
<li><p><strong>y_data</strong> (<em>array-like</em>) – Observed data for ‘y’ in the joint distribution with ‘x’.</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em><em>, </em><em>optional</em>) – Parameters for the kernel function used in the Nadaraya-Watson estimator.
If not provided, default parameters are used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The estimated conditional density of ‘y’ given ‘x’.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Define joint distribution data for ‘x’ and ‘y’</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>Values for conditional density estimation</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>Compute the conditional density</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conditional_density</span> <span class="o">=</span> <span class="n">kernel_conditional_density_estimator</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="n">y_vals</span><span class="p">,</span> <span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">rejection_sampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proposed_sample</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acceptance_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Perform rejection sampling on a set of proposed samples.</p>
<p>This function implements the rejection sampling algorithm, a technique in Monte Carlo methods.
It evaluates each proposed sample against an acceptance criterion based on the sample’s probability and
an acceptance ratio. Samples are accepted with a probability proportional to their probability in the
target distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>proposed_sample</strong> (<em>array-like</em>) – An array of proposed samples to be evaluated.</p></li>
<li><p><strong>probas</strong> (<em>array-like</em>) – An array of probabilities corresponding to each proposed sample.</p></li>
<li><p><strong>acceptance_ratio</strong> (<em>float</em><em>, </em><em>optional</em>) – A threshold ratio for accepting samples. This value can be used
to control the acceptance rate. Default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of samples that are accepted based on the rejection sampling criterion.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Proposed samples and their probabilities</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">proposed_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>Perform rejection sampling</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">accepted_samples</span> <span class="o">=</span> <span class="n">rejection_sampling</span><span class="p">(</span><span class="n">proposed_samples</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">)</span>
</pre></div>
</div>
<p>Note:
The function assumes that the proposed samples and their probabilities are of the same length.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">get_normals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">get_uniforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Generate uniformly distributed random samples from normally distributed samples.</p>
<p>This function first generates random samples from a normal distribution and then
transforms them into a uniform distribution using the error function (erf). It’s
based on the probability integral transform where the Gaussian CDF is used for this conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<em>int</em>) – The number of samples to generate.</p></li>
<li><p><strong>D</strong> (<em>int</em>) – The dimensionality of each sample.</p></li>
<li><p><strong>nmax</strong> (<em>int</em>) – <p>.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array of shape (N, D) containing uniformly distributed random samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Generate 100 samples with 2 dimensions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">uniform_samples</span> <span class="o">=</span> <span class="n">get_uniforms</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">get_uniforms_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">get_normals_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">get_random_normals_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">get_random_uniforms_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">kmeans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Perform K-means clustering on a dataset.</p>
<p>This function applies the K-means clustering algorithm to partition the input data into ‘Ny’ clusters.
It uses the KMeans implementation from Scikit-Learn. The number of clusters, initialization method, and
other parameters of the KMeans algorithm can be specified via keyword arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like</em><em> or </em><em>DataFrame</em>) – Input data for clustering. Should be in a suitable format for clustering (e.g., numerical).</p></li>
<li><p><strong>**kwargs</strong> – Arbitrary keyword arguments, which may include:
Ny (int, optional): The number of clusters to form. Default is the number of rows in ‘x’.
init (str, optional): Method for initialization (‘k-means++’, ‘random’, or an ndarray). Default is ‘k-means++’.
max_iter (int, optional): Maximum number of iterations of the k-means algorithm. Default is 300.
random_state (int, optional): Determines random number generation for centroid initialization.
Use an int for reproducibility. Default is 42.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Cluster centers if ‘Ny’ is less than the number of rows in ‘x’, otherwise returns ‘x’ as is.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like or DataFrame</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Example with NumPy array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Ny</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Example with pandas DataFrame</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feature1&#39;</span><span class="p">,</span> <span class="s1">&#39;feature2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">Ny</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Note:
This function requires Scikit-Learn’s KMeans implementation. Ensure that sklearn.cluster.KMeans is imported.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">MiniBatchkmeans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Perform mini-batch K-means clustering on a dataset.</p>
<p>This function applies the mini-batch K-means clustering algorithm, an efficient variant of
the standard K-means algorithm, to partition the input data into ‘Ny’ clusters. It is particularly
useful for large datasets. The function uses the MiniBatchKMeans implementation from Scikit-Learn.
The number of clusters, batch size, and other parameters of the MiniBatchKMeans algorithm can be
specified via keyword arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like</em><em> or </em><em>DataFrame</em>) – Input data for clustering. Should be in a format suitable for clustering (e.g., numerical).</p></li>
<li><p><strong>**kwargs</strong> – Arbitrary keyword arguments, which may include:
Ny (int, optional): The number of clusters to form. Default is the number of rows in ‘x’.
max_iter (int, optional): Maximum number of iterations of the mini-batch k-means algorithm. Default is 300.
random_state (int, optional): Determines random number generation for centroid initialization. Use an int for reproducibility. Default is 42.
batch_size (int, optional): Size of the mini-batches. Default is 4352 (256*17).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Cluster centers if ‘Ny’ is less than the number of rows in ‘x’, otherwise returns ‘x’ as is.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like or DataFrame</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Example with NumPy array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">MiniBatchkmeans</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Ny</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Example with pandas DataFrame</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;feature1&#39;</span><span class="p">,</span> <span class="s1">&#39;feature2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">MiniBatchkmeans</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">Ny</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Note:
This function requires Scikit-Learn’s MiniBatchKMeans implementation. Ensure that sklearn.cluster.MiniBatchKMeans is imported.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">codpy.sampling.</span></span><span class="sig-name descname"><span class="pre">sharp_discrepancy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</section>
<section id="module-contents">
<h2>Module contents<a class="headerlink" href="#module-contents" title="Link to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lalg.html" class="btn btn-neutral float-left" title="Linear Algebra module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="documentation.html" class="btn btn-neutral float-right" title="Documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Jean-Marc MERCIER, Shohruh MIRYUSUPOV.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>